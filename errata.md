# 『병행 프로그래밍 입문』정오표

아래와 같은 오기가 있어 내용을 정정합니다.

## 1쇄

| 위치 | 수정 전 | 수정 후 |
| ---- | ---- | ---- |

## 보충 설명

### 3.9 베이커리 알고리즘

베이커리 알고리즘의 설명이 부족해 보충 설명한다.

베이커리 알고리즘은 아토믹 명령을 사용하지 않고 N개의 스레드 사이에서 Mytex를 실현하는 알고리즘이다.

단, N은 고정값이 동적으로 변하지 않는다.


P##에서 정의한 `entering`과 `ticket`은 각각 `i`번째의 스레드가 티켓을 얻은 상태인가라는 `i`번째 스레드의 티켓을 저장하는 배열이다.

따라서 p## 앞부분에서 정의한 `BakerlyLock` 구조체에는 다음과 같은 주석을 추가하는 편이 좋을 것이다.

```rust
// 베이커리 알고리즘용 타입 ❹
struct BakeryLock {
    entering: [bool; NUM_THREADS],       // i번째 스레드가 티켓을 획득 중이면 entering[i]는 true
    tickets: [Option<u64>; NUM_THREADS], // i번째 스레드의 티켓은 ticket[i]
}
```

자신의 스레드 번호가 i일 때, 그 스레드 i가 록을 획득하려면 티켓 획득, 다른 스레드의 처리 종료 대기라는 2가지를 수행해야 한다.

먼저 다음과 같이 티켓을 획득한다.

1. `entering[i] = true`로 하고 티켓을 획득 중임을 설정.
2. `tickets[i]`에서 티켓 번호의 최댓값을 얻음.
3. 2에서 얻은 최댓값 + 1을 자신의 티켓 번호로 `tickets[i]`에 설정
4. `entering[i] = false`로 설정

이후 다음과 같이 자신 이외의 다른 스레드 `j`(0에서 `NUM_THREADS-1`, 단 `i` 이외)의 처리가 종료되는 것을 대기한다. 구체적인 대기 과정은 다음과 같다.

1. `entering[j] == false`이 될 때까지 대기. 즉, 다른 스레드가 티켓을 취득 중이면 대기..
2. `ticket[j]`의 값이 자신의 티켓 번호보자 작거나, 티켓 번호가 같고 자신의 스레드 번호가 `j` 볻 작으면 루프로 대기.

이 두 가지 처리가 종료되면 록을 획득하게 되며, 3.9에서 나타낸 `lock` 함수가 이를 처리한다.
